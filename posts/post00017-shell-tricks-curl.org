Шелл-трюки: выпуск 3
#шелл_трюки

Возможности оболочки командного интерпретатора можно расширить невероятно, если вспомнить о том, что
(1) вам из неё доступен весь мир
(2) вы можете менять этот мир заранее.
Для этого вам даже не нужны права рута локально. Собственно, вам даже не нужны права записи, разве что только
на уровне кэширования файлов. Всё остальное — внешний мир и доступные там ресурсы. И вы везде, в любом шелле, в любой системе,
чувствуете себя как дома.

Как же сделать Интернет частью своего шелла?

* Приятные сервисы

Давайте начнём с простого.

Как вы смотрите, под каким адресом вы видны в Интернете?
Зайти на другую машину по ssh и там сделать

  w

или зайти в браузер и там открыть myipaddress.com или что-то ещё?

Самый быстрый способ, не требующий ни браузера, ни внешнего компьютера:

  curl ifcfg.me

curl обращается к web-серверу ifcfg.me и возвращает то, что выдаёт тот.
А сервер настроен таким образом, что возвращает адрес, с которого пришёл запрос.
(аналогичным образом работают ident.me, wgetip.com, eth0.me и ещё десятки аналогичных сервисов).

Кстати, для того чтобы найти свой IP-адрес, не нужен даже HTTP/HTTPS.
Это можно сделать с помощью DNS: нужно разрезолвить адрес `myip.opendns.com`
на сервере `resolver1.opendns.com`. Используя dig, это выглядит так:

  dig +short myip.opendns.com @resolver1.opendns.com

Очень быстро работает, намного быстрее чем по HTTP.

Но вернёмся к curl.
Что ещё можно полезного узнать из консоли с помощью curl?
Например, погоду:

  curl wttr.in

По-видимому, название происходит от немецкого Wetter; которое, в свою очередь, кстати, произошло от слова *ветер*.

По умолчанию показывается погода в вашем городе,
но можно посмотреть и в любом другом:

  $ curl wttr.in/Paris
  
(не будем приводить форматирование, вконтакт его всё равно поломает, для получения максимального
кайфа нужно сделать запрос в консоли).

В качестве названий мест можно использовать коды аэропортов (путешественники наверняка помнят бирки с надписями
SVO и DME на своём багаже)

  $ curl wttr.in/svo
  Weather for IATA: svo, Sheremetyevo International Airport, Russia

или даже доменные имена:

  $ curl wttr.in/@cisco.com
  Weather for City: San Jose, United States of America

curl можно использовать не только для получения информации, но и для её отправки.
Например, для того чтобы запостить файл или любой текст на clbin.com (напоминает pastebin):

  $ ps aux | curl -F 'clbin=<-' clbin.com

(если локально установлена программа clbin, то ещё проще: ps aux | clbin).
Кстати, можно постить не только текст, но и картинки.
Например, запостить скриншот своего экрана:

  $ scrot -e 'curl -F "clbin=@$f" https://clbin.com'

(scrot это порграмма для создания скриншотов).

Аналогично работает `sprunge.us` и несколько других сайтов.
ix.io ещё лучше. Поддерживает аутентификацию, переписывание контента,
различные варианты форматирования, ну и самый короткий из них всех URL.

Клиент ix можно получить с самого ix:

  $ curl ix.io/client > ix

Если подходить более обстоятельно, то лучше воспользоваться github или bitbucket.
Вы создаёте репозиторий с нужными файлами там, редактируете их, разиваете.
Использовать вы можете их напрямую из любого шелла, обращаясь к ним напрямую.


* Don't pipe to your shell

curl использовать настолько приятно, что сразу же возникает желание
читать им готовые скрипты и исполнять их в шелле.
Например, вы можете создать скрипт, который инициализирует
вашу рабочую среду (настраивает приглашение, раскладку, алиасы и так далее),
сохранить его на github или pastebin и использовать его для инициализации
рабочей среды на неизвестных машинах.

Чтобы было легче запомнить путь к вашему скрипту, вы можете создать
на него ссылку в tinyurl или другом аналогичном сервисе.

И потом использовать так:

  curl -L tinyurl.com/setup-my-env | sh -s

или так, если вам нужно не просто выполнить код, а настроить текущую оболочку:

  . <( curl -L tinyurl.com/setup-my-env )
 
(в этом случае вы исполняете код не в дочернем процессе, а в текущем).-*019

Лучше, конечно, сохранять ваши настроечные скрипты не просто в pastebin,
а использовать для этого github или другую аналогичную
службу, которая позволяет вам вносить изменения в ваши файлы
или URL-редиректор, который позволяет редактировать оригинальные URL (например, tiny.cc).

Однако прямое исполнение в шелле кода полученного с помощью curl
имеет большой недостаток, о котором никогда не надо забывать.
Точнее даже два: первый, очевидный, нет никакой уверенности, что вы не стали жертвой
MITM-атаки, и код действительно идёт оттуда, откуда вы думаете.

Второй менее очевидный, но более интересный: что произойдёт, если соединение оборвётся
посреди передачи? Тогда выполнится кусок кода, который случайно может оказаться
совсем не таким, как вы ожидали.

Представьте, что в вашем скрипте есть строчка, которая удаляет какой-то рабочий каталог
в вашей системе:

  rm -rf /var/tmp/temp-dir-XXXXX

Но тут при передаче связь разрывается и как на зло ровно после символов /var:
  
  rm -rf /var

Вероятность этого, конечно, очень мала, и кроме того с правами обычного пользователя
команда безобидна, но однако при неблагоприятном стечении обстоятельств возможны
неприятные последствия.

Чтобы исключить их, нужно внутри передаваемого текста использовать простую конструкцию-обёртку:

  main()
  {
     # тут идёт ваш скрипт
  }
  main
  unset main

Если передача обрывается на середине, то функция не исполнится.
Если передаётся вся, то исполнится без ошибок.
Самое неприятное, что может произойти, что функция будет описана
и не удалена после этого. Хотя это и не совсем чисто, но безвредно.

* Навороты curl

curl поддерживает очень много полезных возможностей,
в частности, он позволяет:

 * запросы различных типов, а не только GET (поддерживаются PUT, POST и DELETE); 
 * передавать данные формы, включая аттачменты;
 * обрабатывать перенаправления HTTP (-L);
 * проходить аутентификацию со стороны сервера;
 * работать не только с HTTP и HTTPS но и рядом других протоколов, в частности с DICT и даже SMTP.

Особо приятны тут первые два пункта. С их помощью не выходя из шелла
можно полноценно работать (и автоматизировать) с веб-сервисами.

Многие веб-службы требуют сначала пройти аутентификацию через веб-форму,
а потом уже делать что-то дальше.
В этом случае нужно сохранить cookies, которые отправляет сервер при аутентификации,
а потом их всегда отправлять.

Логинимся и сохраняем cookies:

  $ curl -X POST -c cookies.txt -u "user1:password1" myserver.com/login

Работаем дальше с сервисом:

  $ curl -b cookies.txt myserver.com/page1


* Работа с json

Данные могут быть не обязательно в текстовой форме, предназначенной для отображения в консоли.
Огромнейшее количество данных доступно в виде JSON (специального формата, принятого для обмена в Web).

Более того, полноценные REST-приложения (а их сейчас большинство) именно так и работают.
Клиентская часть, работающая в браузере, взаимодействует с сервером через HTTP-интерфейс,
используя методы GET, POST, PUT и DELETE, данные при этом представлены, как правило, в JSON-формате.

Как работать с JSON в командной строке. Поробуем.

Например, поиработаем с REST-сервером, предоставлюящем данные о странах в виде JSON.

Вот, например, Франция:

  https://restcountries.eu/rest/v1/name/france

Если мы просто обратимся к URL и прочитаем данные о стране:

  $ curl https://restcountries.eu/rest/v1/name/france
  [{"name":"France","capital":"Paris",...

мы увидим просто все данные в одну строку.

Ничего не разберёшь!

Нужно отформатировать данные и выдать их в красивенькой форме.
Самый простой способ, не требующий инсталляции дополнительных инструментов:

  $ curl https://.... | python -mjson.tool

Инсталлировать ничего не надо, Python уже, как правило, в системе есть.

Если нужно не только отформатировать, но и получить какие-то данные,
например вытащить информацию о населении страны, удобнее использовать программу jq (суперская прога, 
но требует инсталляции):

  $ curl https://... | jq .

(обратите внимание на . в конце).

Получить конкретное значение можно тоже

  $ curl https://... | jq .[].capital
  "Paris"

(мы посмотрели сначала как выглядят данные, увидели где столица, и теперь к ней и обращаемся).

Вообще jq поддерживает сразу целый язык запросов, довольно мощный,
и с его помощью можно выделять и обрабатывать довольно сложные данные:

Смотрим население и площадь некоторых интересующих нас стран.
Запрос делаем в одну команду:

  $ curl --silent .../{france,germany,spain,netherlands,poland,ukraine,russia} | jq '.[]["name","population","area"]'
  "France"
  66186000
  640679
  "Germany"
  81083600
  357114
  "Spain"
  46439864
  505992
  "Netherlands"
  16916000
  41850
  "Poland"
  38484000
  312679
  "Ukraine"
  42836922
  603700
  "Russia"
  146556330
  17124442

JSON это сегодня один из основных форматов сериализации данных,
поэтому он поддерживается всеми полноценными языками программирования.

  pjson            # python, pip install pjson
  prettify_json.rb # ruby, gem install json
  underscore print # javascript, npm install -g underscore-cli
  json             # javascript, npm install -g json
  json_pp          # perl, уже установлен скорее всего

