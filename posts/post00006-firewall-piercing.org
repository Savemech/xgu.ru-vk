Firewall piercing или о том, как прорубить себе полноценный выход в сеть

#записки_из_подполья

Начинаем очередной цикл — Записки из подполья.

Здесь мы будем с вами говорить о вещах, касающихся различных аспектов использования систем,
изначально не предусмотренных их создателем. Это не всегда то, что обозначается страшным словом безопасность.
Хотя часто тонкая грань, разделяющая эти два понятия, может отказаться настолько тонкой,
что в итоге решение зависит только от точки зрения. Для вас это расширенное использование возможностей
системы, а для них — взлом, хак и вопиющее нарушение безопасности. В любом случае, знайте, пристрастие
к использованию недокументированных возможностей системы — прямой путь в подполье.

(Разумеется, что всё, что мы будем рассматривать в рамках этого цикла, мы делаем исключительно
с академической точки зрения, или с точки зрения повышения безопасности наших систем, но ни в коем
случае не наоборот. Помните, что любое недокументированное использование систем, может быть, автоматически
и несанкционированным и иногда и противоправным. Никогда не забывайте об этом.).

Логичным было бы начать этот цикл с такого простого вопроса: а как, собственно, пишутся 
записки из подполья? Ну пишутся они известно как: молоком на белой бумаге, молоком из хлебной чернильницы.
А вот как они передаются?

Итак, сегодня мы поговорим о том, как можно из маленького-маленького кругом ограниченного, отфильтрованного
и урезанного доступа, прорубить себе полноценный выход в сеть.

* Введение

Задача очень простая — у вас есть ограниченная возможность пользоваться сетью,
а вы хотите получить полноценный доступ наружу (если есть права рута на локальной машине)
или хотя бы возможность установки TCP-соединений, в первую очередь SSH, если таких прав нет.

Понятно, что как только вы установите SSH-соединение с внешним миром,
дальше это уже дело техники — вы делаете проброску портов (port forwarding)
и получаете доступ к любому порту снаружи, который вас интересует.

Как же выбраться наружу? Давайте посмотрим, какие у нас есть возможности.

Во всех (или почти во всех) рассмотренных методах предполагается,
что снаружи вас кто-то ждёт — у вас есть точка в Интернете, на которой
вы располагаете полными правами, и к которой вам собственно и нужно подключиться.
Это может быть ваш домашний компьютер (если у него есть честный IP-адрес или по крайней
мере пробрасываемые наружу порты), это может быть VPS или полноценный сервер в Интернете
или это может быть инстанция в облачной (IaaS) системе.

Как правило, все из вас располагают такой точкой, но если нет,
проблему тоже можно решить. Рассмотрим это тоже.

* Terminal in Browser

Начнём с простого. У вас есть браузер и вам не нужно ничего другого,
как только залогинится на свою машину и просто поработать там немного.
Запусть mutt, freetalk, подключиться к вашей screen/tmux-сессии, словом, почувствовать
себя как дома.

Вы не хотите запускать ничего локально. Вас не интересуют никакие соединения
на локальной стороне. 

В этом случае вам просто нужно запустить снаружи эмулятор терминала для web.

Сегодня есть несколько в большей или меньшей степени полноценных эмуляторов терминала
для web, но в общем, сегодня все они уже достаточно качественные и позволяют организовать
комфортную работу.

Лучшее на сегодня:

 * https://github.com/krishnasrinivas/wetty Терминал в Web (типа ajaxterm, только намного круче)
 * https://github.com/chjj/tty.js Терминал изначально основанный на реализации Фабриса Беллара для его jslinux'а

Раньше был популярен ajaxterm, но он значительно уступает более современным tty.js и wetty.


* SSH-over-PROXY

Усложняем задачу. 

Что если мы хотим получить не только терминал в браузере, но полноценный доступ к удалённому серверу по SSH?
У нас есть только HTTP-прокси и больше ничего нет.

В зависимости от того, разрешён нам метод CONNECT или нет, задачу мощно решить по-разному.

Чаще всего метод CONNECT разрешён, по крайней мере для 443 порта.
Если это так, то всё просто. Используем для этого `corkscrew`, Если есть метод CONNECT:

  ssh user@server -o "ProxyCommand corkscrew $proxy_ip_or_domain_name $proxy_port $destination_ip_or_domain_name $destination_port"

При более суровых условиях метод CONNECT может и не быть разрешён, и тогда придётся
работать поверх обычных GET и POST. Уж они-то разрешены будут, если выход через прокси вообще есть.

Используем httptunnel

  https://github.com/larsbrinkhoff/httptunnel

На сервере (в инете):

  hts -F localhost:22 8888

На клиенте (в подполье):

  htc -F 2222 -P PROXY:8000 REMOTE:8888

Дальше вы просто обращаетесь на локальный порт 2222, и готово — вы на своём удалённой точке,
и работаете вы, как мы и договаривались, через прокси-сервер, на котором, при этом разрешён только GET и POST.

* ICMP-tunelling

Усложняем задачу дальше.

У вас нет и прокси. Скорее всего пинга у вас тогда тоже не будет (ну в самом деле, кто же вам его откроет,
если вам судя по всему никакого доступа вообще не предполагается), однако возможна одна довольно часто распространённая
ошибка в настройке, которая позволит вам выйти наружу.

Начнём, тем не менее с простого. Если вам разрешён ICMP-трафик, вы можете проложить по нему туннель
наружу одним из многочисленных способов. Используйте любой из этих инструментов:

  https://github.com/DhavalKapil/icmptunnel
  http://www.cs.uit.no/~daniels/PingTunnel/
  http://code.gerade.org/hans/

Например, с помощью icmptunnel вы делаете это так:

На сервере:

  ./icmptunnel -s 10.0.1.1

На клиенте:

  ./icmptunnel -c <server>

В результате создаётся интерфейс, через который можно маршрутизировать трафик наружу.

Тут следует учесть, что создание ICMP-трафика, впрочем как и создание сетевого интерфейса,
действие требующее привелегий суперпользователя (и даже ping имеет SUID-бит), поэтому без прав рута на машине
сделать ICMP-туннель у вас не получится.

Но что, если сквозной ICMP-трафик заблокирован? Тогда у вас есть ещё один шанс, если файрвол настроен
недостаточно хорошо (хотя шанс и довольно маленький).

Вы можете подставить адрес вашего внешнего компьютера в качестве источника ICMP-пакета (echo request),
и ответ уйдёт на этот внешний компьютер (echo reply). Интересно тут то, что в ответе будут содержаться
те же данные, которые вы отправили в echo request'е. В обратную сторону данные должны поступать точно таким же 
путём.

Разумеется, если на брандмауэре настроена rp-фильтрация (то есть, сопоставление адреса отправителя и интерфейса,
через который пришёл от него пакет), то этот метод работать не будет (как и в ряде других случаев, например,
если по дороге стоит ещё один брандмауэр и т.д.).

Подробнее о методе вы можете прочитать здесь: http://archive.cert.uni-stuttgart.de/bugtraq/2004/09/msg00267.html

* DNS-tunelling

Усложняем задачу ещё дальше. У вас нет ни прокси, ни пингов, ничего. Почти ничего. Есть только DNS.

Это ситуация, надо сказать, достаточно распространённая. В частности, во многих точках публичного доступа по Wi-Fi
DNS открыт и хорошо резолвится, однако для открытия остального трафика или хотя бы прокси
от вас требуют регистрации или денег. Часто и в обычных корпоративных сетях там где никакого доступа больше нет
DNS-резолвинг всё равно работает.

В подробностях об этом методе вы можете прочитать в бессмертной статье

  http://xgu.ru/wiki/DNS-tunneling

Лучше всего с решением задачи справится тут iodine.

  https://github.com/yarrick/iodine

Итак, если имена резолвятся, этого достаточно, чтобы получить полноценный доступ наружу.

* Что если нет прав рута

В почти во всех рассмотреных выше примерах мы отталкивались от предполажения,
что локально у нас есть права рута. Что, однако, на практике совсем не всегда так.

Права рута не нужны, если вы просто организуете проброску TCP-порта без создания
локального сетевого интерфейса и без маршрутизации. При этом вы не должны пользоваться
ICMP-пакетами и другим хитрым трафиком.

В ещё более сложных случаях вам запрещена установка софта локально (noexec на /home),
в более сложных — у вас нет вообще локального шелла.
В любом случае у вас остаётся возможность удалённого доступа к терминалу через web.

Если же вам нужен более полный доступ, выходом может быть установка в разрыв ethernet-подключения
компьютера Raspberry Pi или подобного устройства. О том как правильно обрабатывать транзитный трафик,
и как сделать так, чтобы устройство не было заметно ни со стороны компьютера, ни со стороны сети,
а также как правильно перехватывать и обрабатывать трафик, предназначенный самому устройству,
мы поговорим как-нибудь в следующий раз, сейчас же просто знайте, что такой метод существует
и успешно используется.

* Друзья снаружи

Но что, если снаружи вас никто не ждёт, что если вы один, совсем один в этом мире?
Ну что ж, тогда дела плохи, мне нечем вас утешить, разве что только этим: подумайте, а зачем
вам вообще наружу, если у вас там совсем никого нет?
На самом деле всегда есть кто-то, кто вас где-то ждёт, вы, может быть, просто забыли.

Ну а в случае с компьютерными системами всё ещё намного проще.

Методов организовать себе сообщника снаружи, когда вы уже внутри, есть великое множество,
но давайте я расскажу какой-нибудь один, самый простой.

Безусловно, намного проще приготовить всё заранее, отладить, протестировать,
и спокойно ждать того момента, когда вам потребуется ваша внешняя точка.
Как правило, такая точка у вас всегда есть, и даже не одна.

Но всё же, что если её нет, а вы уже внутри? Или вы не хотите выдавать ни одну ваших точек?

Итак задача: организовать точку удалённого подключения в интернете, не пользуясь ничем
кроме браузера и общедоступных ресурсов в Интернете.

Как уже было сказано, методов много, рассмотрим простейший.

1. Запускаете в Amazon EC2 Linux-инстанцию;
2. Открываете доступ к её 80 или 443 порту;
3. Устанавливаете на неё эмулятор терминала для веб такой как tty.js или подобный;
4. Создаёте пользователя, с помощью которого вы будете подключаться к инстанции;
5. Подключаетесь. Всё, вы в терминале. Снаружи. Задача решена.

"Да нууууу... Что за бред такой? Мы же вроде как взрослые люди? Как можно зайти на машину и установить
там то да сё, если доступа к ней нет? Короче детский сад. Так я и сам могу"

Да, это верно, действительно, зайти на машину и установить на ней софт не получится, очевидно.
Однако всё же установить софт можно!

Конечно, лучше всего было бы, если бы мы заранее заточили нужный нам образ, сохранили его на s3,
и потом просто стартанули бы с него. Да, это было бы возможно,
но это нарушает условия задачи — мы не готовимся заранее и пользуемся только общедоступными ресурсами.

Но может быть, можно ли как-то приготовить образ из общедоступных?

Именно!

Если вы возьмёте стандартный Linux-образ лежащий на Amazon, например, такой как Amazon Linux,
в нём, как правило, предусмотрена возможность постстартовой доточки. Чаще всего в настоящее время
это делается с помощью cloud-init или подобного пакета. Работает он очень просто. Он считывает специальный
URL, так называемые user-данные, userdata и исполняет их.

Нам хватит, если мы сможем передать всего лишь одну строку, которая будет исполнена образом.
Например:

  curl http://pastebin.com/raw.php?i=t8nt6UJf | sh -s

Сначала вы создаёте свой пост на pastebin'е (или на github, или где угодно, где вы можете запостить данные прямо из веб),
который и исполняется при старте.
В этом посте вы пишете ваши команды, необходимые для старта веб-терминала.

Команды исполняются при старте инстанции (скрипт будет передан curl'ом на вход sh -s, который его и исполнит).

Остался единственный вопрос: как передать собственно вызов curl внутрь инстанции?
Как мы уже говорили, делается это с помощью userdata инстанции, которую можно установить через веб-интерфейс AWS.

Все действия потребуют меньше пяти минут времени.
